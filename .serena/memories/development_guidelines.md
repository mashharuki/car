# 開発ガイドライン（AGENTS.mdより）

## AI駆動開発の方針

### Kiro-style開発フレームワーク
このプロジェクトは **Kiro-style Spec Driven Development** と **t-wada氏のTest Driven Development** を組み合わせたAI-DLC（AI Development Life Cycle）を採用。

### 基本原則
1. **思考**: 英語で行う
2. **出力**: わかりやすく自然な日本語
3. **ステップバイステップ**: 複雑な処理は段階的に
4. **プロジェクトアクティベート**: 毎回実施
5. **オンボーディング**: 未実施の場合は必ず実行

## 必須スキルの使用

以下のスキルを該当タスクで**必ず使用**：

### circom-dev
- **対象**: ZK証明の回路開発、circom実装、算術回路の設計・テスト
- **用途**: `pkgs/circuit/` での開発時

### vercel-react-best-practices
- **対象**: React/Next.jsコンポーネント作成、パフォーマンス最適化
- **用途**: `pkgs/frontend/` での開発時

### web-design-guidelines
- **対象**: UI/UXレビュー、アクセシビリティチェック、デザイン監査
- **用途**: フロントエンド実装・レビュー時

### hackathon-guideline
- **対象**: 次世代オートモーティブ生成AIハッカソン提出用アプリ開発
- **用途**: このリポジトリでの開発全般

### erc4337-privacy-wallet-dev
- **対象**: ERC4337規格準拠のプライバシー保護Wallet開発
- **用途**: SmartAccount実装時

## Sub Agentの使用

### apple-style-ui-designer
- **対象**: Apple社UIデザインガイドラインに沿ったUI設計・開発
- **用途**: モバイルアプリデザイン、高品質なUI実装時

## Kiroワークフロー

### プロジェクトコンテキスト
- **Steering**: `.kiro/steering/` - プロジェクト全体のルールとコンテキスト
- **Specs**: `.kiro/specs/` - 個別機能の開発プロセス形式化

### Minimal Workflow

#### Phase 0（オプション）
```bash
/kiro:steering
/kiro:steering-custom
```

#### Phase 1（仕様策定）
```bash
# 1. 仕様初期化
/kiro:spec-init "description"

# 2. 要件定義
/kiro:spec-requirements {feature}

# 3. ギャップ分析（既存コードベースの場合）
/kiro:validate-gap {feature}

# 4. 設計
/kiro:spec-design {feature} [-y]

# 5. 設計レビュー（オプション）
/kiro:validate-design {feature}

# 6. タスク分解
/kiro:spec-tasks {feature} [-y]
```

#### Phase 2（実装）
```bash
# 実装実行
/kiro:spec-impl {feature} [tasks]

# 実装検証（オプション）
/kiro:validate-impl {feature}
```

#### 進捗確認
```bash
# いつでも実行可能
/kiro:spec-status {feature}
```

### 承認ワークフロー
- 3フェーズ承認: Requirements → Design → Tasks → Implementation
- 各フェーズで人間レビュー必須
- `-y` フラグは意図的な高速化のみ使用

## 開発の基本理念

### 品質意識
- 動くコードだけでなく、品質・保守性・安全性を重視
- プロジェクト段階（プロトタイプ/MVP/本番）に応じたバランス
- 問題発見時は放置せず対処または明示的記録

### ボーイスカウトルール
コードを見つけた時よりも良い状態で残す

## エラーハンドリングの原則

### すべてのエラーを解決
- 関連が薄く見えるエラーも必ず対処
- エラー抑制（`@ts-ignore`、`try-catch`での握りつぶし）禁止
- 根本原因を修正

### 早期検出
- 早期にエラーを検出
- 明確なエラーメッセージ提供
- エラーケースもテストカバー
- 外部API/ネットワークは失敗前提で設計

## コード品質基準

### DRY原則
重複を避け、単一の信頼できる情報源を維持

### 明確な命名
意味のある変数名・関数名で意図を伝達

### 一貫性
プロジェクト全体で一貫したコーディングスタイル

### 小さな問題も修正
発見次第対処（Broken Windows理論）

### コメント規約
「なぜ」を説明、「何を」はコードで表現

## テスト規律

### テストをスキップしない
問題があれば修正、スキップ禁止

### 振る舞いテスト
実装詳細ではなく振る舞いをテスト

### テスト独立性
テスト間の依存を避け、任意順序で実行可能

### 高速・決定的
常に同じ結果を返す高速なテスト

### カバレッジ
指標であり、質の高いテストを重視

## 保守性とリファクタリング

### 継続的改善
機能追加と同時に既存コード改善を検討

### 段階的変更
大規模変更は小ステップに分割

### 積極的削除
未使用コードは削除

### 依存関係更新
セキュリティと互換性のため定期更新

### 技術的負債の記録
コメントやドキュメントで明示的に記録

## セキュリティ

### 秘密情報管理
APIキー、パスワードは環境変数（ハードコード禁止）

### 入力検証
すべての外部入力を検証

### 最小権限の原則
必要最小限の権限で動作

### 依存関係管理
不要な依存を避ける

### 定期監査
セキュリティ監査ツールを定期実行

## パフォーマンス意識

### 計測ベース最適化
推測ではなく計測に基づいて最適化

### 初期段階から拡張性考慮
スケーラビリティを意識

### 遅延読み込み
必要になるまでリソース読み込みを遅延

### キャッシュ戦略
有効期限と無効化戦略を明確化

### N+1問題回避
オーバーフェッチを避ける

## 信頼性確保

### タイムアウト処理
適切なタイムアウト設定

### リトライ機構
指数バックオフを考慮したリトライ

### サーキットブレーカー
障害の連鎖を防ぐ

### 一時的障害耐性
一時的障害に対する耐性

### 可観測性
適切なログとメトリクス

## プロジェクトコンテキスト理解

### バランス
ビジネス要件と技術要件のバランス

### フェーズ適応
現在のフェーズで必要な品質レベルを判断

### 最低基準維持
時間制約下でも最低限の品質基準を維持

### 技術レベル考慮
チーム全体の技術レベルに合わせた実装選択

## トレードオフ認識

### 完璧は不可能
銀の弾丸は存在しない

### 最適バランス
制約の中で最適なバランスを発見

### 優先順位
プロトタイプなら簡潔さ、本番なら堅牢性を優先

### 妥協点の文書化
妥協点とその理由を明確化

## Git運用

### コンベンショナルコミット
`feat:`, `fix:`, `docs:`, `test:`, `refactor:`, `chore:`

### 原子的コミット
単一の変更に焦点

### 明確なメッセージ
説明的なコミットメッセージ（英語）

### ブランチ戦略
main/masterへの直接コミット回避

## コードレビュー姿勢

### 建設的受容
改善提案として受け取る

### コードに焦点
個人ではなくコードに焦点

### 説明責任
変更理由と影響を明確に説明

### 学習機会
フィードバックを歓迎

## デバッグベストプラクティス

### 再現手順確立
問題を確実に再現

### 二分探索
範囲を絞り込む

### 最近の変更調査
最近の変更から開始

### 適切なツール活用
デバッガー、プロファイラー使用

### 知識共有
調査結果と解決策を記録

## 依存関係管理

### 必要性確認
本当に必要なもののみ追加

### ロックファイルコミット
`pnpm-lock.yaml`を必ずコミット

### 事前確認
ライセンス、サイズ、メンテナンス状況確認

### 定期更新
セキュリティパッチとバグ修正適用

## ドキュメント基準

### README充実
概要、セットアップ、使用方法を明記

### コードと同期
ドキュメントをコードと同期更新

### 実例優先
実例を示すことを優先

### 設計決定記録
重要な設計判断はADRで記録

## 継続的改善

### 学習活用
学んだことを次のプロジェクトに活用

### 定期振り返り
プロセスを改善

### 新技術評価
適切に評価して取り入れる

### 知識文書化
チームや将来の開発者のため文書化